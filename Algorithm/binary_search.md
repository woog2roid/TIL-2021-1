군대에서 오랜만에 PS를 하는데 이진탐색 문제로 간단하게 풀려고 했다가, 어떻게 짜야하는 지 기억이 안났다는 사실에 충격을 받고... 간단하게 정리하기.  
(이렇게 써두면 나중에 필요할 때 빠르게 기억을 되찾지 않을까 싶은 마음에,)

## binary search
```c++
while(min <= max) { 
	// 계속 진행하다 보면 min, max가 바뀌며 끝이나기에 이렇게 작성
    int mid = (min + max)/2;

    if(arr[mid] == num) return mid;
    else if(arr[mid] < num) {
	/*
	중간 값이 찾고자하는 값보다 작을 경우 --> 수직선 상에서 오른쪽으로 이동해야 하는 경우
	--> 최솟값을 mid + 1로 잡아서 mid밑은 버리기
    */
		min = mid + 1;
    }
	else if {
	/*
	중간 값이 찾고자하는 값보다 큰 경우 --> 수직선 상에서 오른쪽으로 이동해야 하는 경우
	--> 최댓값을 mid - 1로 잡아서 mid위로 버리기
    */
		max = mid - 1;
    }
  }
```

__포인트__ (라기엔 너무 별 거 없지만...)
- while문 안의 조건
- min = mid + 1, max = mid - 1
 
__실제로 문제를 풀 때는, 배열에서 원소를 찾는 것 처럼 정확하게 떨어지지 않고, 오히려 최적해를 찾는 문제들이 많았다. 그럴 땐 당황하지말고 ans를 설정하고 갱신해서 답을 찾아주자!!__

#### 풀어본 문제들
(정리하면 나중에 기억할 때 좋을 듯 해서)

[공유기 설치](https://github.com/woog2roid/PS-in-army.../blob/main/2110.cpp)  
공유기 설치 문제는, cnt == c 일 때, break;를 걸어서 처음에 헷갈렸지만, 예제 테케에서 바로 생각할 수 있었다.
하지만, 설치 가능한 공유기개수가 C보다 클 때도 답이 될거라 생각하지는 못했어서, 조금 많이 돌아간 것 같다. 

[나무 자르기](https://github.com/woog2roid/PS-in-army.../blob/main/2805.cpp)
정확한 값이 나오면 break를 걸고, 정확한 값이 없을 때 최적의 값을 찾기 위해 ans를 갱신해주었다.